'use server'

import { cookies } from 'next/headers'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import * as github from '@/lib/github'
import { modifyCode } from '@/ai/flows/modify-code-with-ai'
import { diffChars } from 'diff';

export async function logout() {
  cookies().set('github_access_token', '', { expires: new Date(0) })
  revalidatePath('/')
  redirect('/')
}

export async function getRepos(token: string) {
    return github.getRepos(token);
}

export async function getBranches(token: string, repoFullName: string) {
    return github.getBranches(token, repoFullName);
}

export async function getFiles(token: string, repoFullName: string, branchName: string) {
    const { tree } = await github.getRepoTree(token, repoFullName, branchName);
    return tree;
}

async function updateReadme(token: string, repo: string, branch: string, commitMessage: string, filePath: string) {
    let readmeContent = "";
    let readmeSha: string | undefined = undefined;

    try {
        const { content, sha } = await github.getFileRawContent(token, repo, 'README.md');
        readmeContent = content;
        readmeSha = sha;
    } catch (error: any) {
        if (error.message.includes("Not Found")) {
            console.log("README.md not found. Creating a new one.");
            readmeContent = `# Change Log\n\nThis log is automatically generated by GitAutomator.\n\n`;
        } else {
            throw error; // Rethrow other errors
        }
    }

    const newEntry = `### Changes to \`${filePath}\`\n\n- **Commit Message:** ${commitMessage}\n- **Date:** ${new Date().toUTCString()}\n\n---\n\n`;
    const updatedContent = newEntry + readmeContent;

    await github.createOrUpdateFile({
        token,
        repo,
        branch,
        filePath: 'README.md',
        newContent: updatedContent,
        commitMessage: 'docs: Update README with recent changes',
        fileSha: readmeSha
    });
}


export async function generateModification(formData: FormData) {
  const token = formData.get('token') as string
  const repo = formData.get('repo') as string
  const file = formData.get('file') as string
  const request = formData.get('request') as string
  
  if (!token || !repo || !file || !request) {
    return { success: false, message: "Missing required fields." }
  }

  try {
    const { content: currentContent, sha: fileSha } = await github.getFileRawContent(token, repo, file);

    const aiResult = await modifyCode({
      request: request,
      fileContent: currentContent,
      filePath: file,
    });

    if (!aiResult.modifiedContent || !aiResult.commitMessage) {
        return { success: false, message: "AI failed to generate valid modifications or a commit message." }
    }
    
    const diff = diffChars(currentContent, aiResult.modifiedContent);

    return { 
        success: true, 
        ...aiResult,
        diff,
        fileSha,
        originalContent: currentContent,
    }
  } catch (error: any) {
    console.error("Modification generation failed:", error)
    return { success: false, message: error.message || 'An unknown error occurred.' }
  }
}

export async function commitModification(formData: FormData) {
    const token = formData.get('token') as string
    const repo = formData.get('repo') as string
    const branch = formData.get('branch') as string
    const file = formData.get('file') as string
    const commitMessage = formData.get('commitMessage') as string
    const modifiedContent = formData.get('modifiedContent') as string
    
    if (!token || !repo || !branch || !file || !commitMessage || !modifiedContent) {
        return { success: false, message: "Missing required fields for commit." }
    }

    try {
        // Refetch the latest SHA right before committing
        const { sha: latestFileSha } = await github.getFileRawContent(token, repo, file);

        await github.createCommitAndPush({
          token,
          repo,
          branch,
          filePath: file,
          newContent: modifiedContent,
          commitMessage: commitMessage,
          fileSha: latestFileSha
        });
    
        try {
            await updateReadme(token, repo, branch, commitMessage, file);
        } catch (readmeError: any) {
            console.error("Could not update README.md:", readmeError);
            return { success: true, message: `Successfully committed changes to ${file} in ${repo}. (README update failed)` }
        }
    
        revalidatePath('/')
        return { success: true, message: `Successfully committed changes to ${file} in ${repo} and updated README.md.` }

    } catch(error: any) {
        console.error("Commit failed:", error)
        return { success: false, message: error.message || 'An unknown error occurred.' }
    }
}


const GENUINE_COMMIT_TASKS = [
    { type: 'feat', description: 'Add section on project setup' },
    { type: 'fix', description: 'Correct typo in installation instructions' },
    { type: 'docs', description: 'Update usage examples' },
    { type: 'style', description: 'Format code snippets for readability' },
    { type: 'refactor', description: 'Restructure installation guide' },
    { type: 'perf', description: 'Optimize image assets in docs' },
    { type: 'test', description: 'Add tests for documentation links' },
    { type: 'chore', description: 'Update contribution guidelines' },
    { type: 'ci', description: 'Configure CI for documentation builds' },
    { type: 'revert', description: 'Revert changes to deployment section' }
];

export async function generateFakeCommits(formData: FormData) {
    const token = formData.get('token') as string;
    const repo = formData.get('repo') as string;
    const branch = formData.get('branch') as string;

    if (!token || !repo || !branch) {
        return { success: false, message: "Missing required fields." };
    }

    try {
        const numCommits = Math.floor(Math.random() * 21) + 10; // Random number between 10 and 30
        for (let i = 0; i < numCommits; i++) {
            let readmeContent = "";
            let readmeSha: string | undefined = undefined;

            // Fetch the latest README content in each iteration
            try {
                const fileData = await github.getFileRawContent(token, repo, 'README.md');
                readmeContent = fileData.content;
                readmeSha = fileData.sha;
            } catch (error: any) {
                if (error.message.includes("Not Found")) {
                    readmeContent = `# ${repo}\n\nThis README was auto-generated by GitAutomator.\n\n## Change Log\n`;
                    // No SHA for a new file
                    readmeSha = undefined; 
                } else {
                    throw error;
                }
            }
            
            const task = GENUINE_COMMIT_TASKS[i % GENUINE_COMMIT_TASKS.length];
            const commitMessage = `${task.type}: ${task.description}`;
            const newContent = `${readmeContent}\n\n- ${new Date().toISOString()}: ${commitMessage}`;

            await github.createOrUpdateFile({
                token,
                repo,
                branch,
                filePath: 'README.md',
                newContent,
                commitMessage,
                fileSha: readmeSha,
            });

            // Small delay to avoid hitting rate limits and to ensure commits have different timestamps
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        revalidatePath('/');
        return { success: true, message: `Successfully generated ${numCommits} genuine commits to README.md.` };

    } catch (error: any) {
        console.error("Fake commit generation failed:", error);
        return { success: false, message: error.message || 'An unknown error occurred.' };
    }
}
